# -*- coding: utf-8 -*-
"""Arabic Handwritten Characters Classifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1klW2rnV5jQ66rlSZbCvvamFti_ZynsDK

Importing libraries
"""

import pathlib
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn import metrics, tree, ensemble
from sklearn.utils import shuffle
import tensorflow as tf
from google.colab import files

"""Checking if device is GPU"""

tf.test.gpu_device_name()

"""Uploading Kaggle token"""

files.upload()

"""Importing Kaggle dataset"""

! pip install kaggle
! mkdir ~/.kaggle
! cp kaggle.json ~/.kaggle/
! chmod 600 ~/.kaggle/kaggle.json

"""Downloading the Arabic Handwritten Characters Dataset"""

! kaggle datasets download -d mloey1/ahcd1

"""Unzipping the dataset to folder Datasets"""

!unzip ahcd1.zip -d Datasets

"""Loading the data"""

dir = pathlib.Path("/content/Datasets/Arabic Handwritten Characters Dataset CSV")

# training data features
train_data = pd.read_csv(dir / "csvTrainImages 13440x1024.csv", header=None)

# training data target
train_target = pd.read_csv(dir / "csvTrainLabel 13440x1.csv", header=None)

# testing data features
test_data = pd.read_csv(dir / "csvTestImages 3360x1024.csv", header=None)

# testing data target
test_target = pd.read_csv(dir / "csvTestLabel 3360x1.csv", header=None)

"""showing the datasets"""

shuff = shuffle(train_data[:100])
fig, ax = plt.subplots(3,3, figsize = (10,10))
axes = ax.flatten()
for i in range(9):
  axes[i].imshow(shuff.values[i].reshape(32,32).transpose(1,0))
plt.show()

print(train_data)
print(train_target)

print(test_data)
print(test_target)

"""# ML(Supervised): Decision Tree Classifier

Creating a decision tree classifier
"""

dtc = tree.DecisionTreeClassifier().fit(train_data, train_target)

"""Making predictions"""

dtc_predections = dtc.predict(test_data)

"""Finding model accuarcy"""

accuracy = metrics.accuracy_score(test_target, dtc_predections)

print(accuracy)

"""Generating classification report"""

dtc_report = metrics.classification_report(test_target, dtc_predections)
print(dtc_report)

"""Implementation"""

img = random.randint(0, len(dtc_predections) - 1)
print("Predection =", dtc_predections[img])
plt.imshow(test_data.values[img].reshape(32,32).transpose(1,0))

"""# ML(Supervised): Random Forest Classifier

Creating a random forest classifier
"""

rfc = ensemble.RandomForestClassifier().fit(train_data, train_target)

"""Making predictions"""

rfc_predections = rfc.predict(test_data)

"""Finding model accuarcy"""

accuracy = metrics.accuracy_score(test_target, rfc_predections)

print(accuracy)

"""Generating classification report"""

rfc_report = metrics.classification_report(test_target, rfc_predections)
print(rfc_report)

"""Implementation"""

img = random.randint(0, len(rfc_predections) - 1)
print("Predection =", rfc_predections[img])
plt.imshow(test_data.values[img].reshape(32,32).transpose(1,0))

"""# DL: Neural Network (NN)

Normalizing the data
"""

train_data = tf.keras.utils.normalize(train_data, axis=1)
test_data = tf.keras.utils.normalize(test_data, axis=1)

"""Neural Network model"""

mode_nn = tf.keras.models.Sequential([
    tf.keras.layers.Dense(1024, activation='relu'),
    tf.keras.layers.Dense(512, activation='relu'),
    tf.keras.layers.Dense(29, activation='softmax')
])

"""compiling the model"""

mode_nn.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')

"""Training the model"""

mode_nn.fit(train_data, train_target, validation_split=0.3, epochs=10)

"""Finding loss and accuracy"""

loss, accuracy = mode_nn.evaluate(test_data, test_target)

print("Accuracy =", accuracy)
print("Loss =", loss)

"""Making predictions"""

ann_predections = mode_nn.predict(test_data)

"""Implementation"""

img = random.randint(0, len(ann_predections) - 1)
print("Predection =", np.argmax(ann_predections[img]))
plt.imshow(test_data.values[img].reshape(32,32).transpose(1,0))

"""# DL: Convolutional Neural Networks (CNN)

Reshaping the data to a numpy array
"""

train_data_cnn = np.reshape(train_data.values, (train_data.shape[0], 32, 32))
print(train_data_cnn.shape)

test_data_cnn = np.reshape(test_data.values, (test_data.shape[0], 32, 32))
print(test_data_cnn.shape)

"""Reshaping the data to a convolutional shape"""

train_data_cnn = train_data_cnn.reshape(train_data_cnn.shape[0], train_data_cnn.shape[1], train_data_cnn.shape[2], 1)
print(train_data_cnn.shape)

test_data_cnn = test_data_cnn.reshape(test_data_cnn.shape[0], test_data_cnn.shape[1], test_data_cnn.shape[2], 1)
print(test_data_cnn.shape)

"""Convolutional Neural Network model"""

model_cnn = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu', input_shape=(32, 32, 1)),
    tf.keras.layers.MaxPool2D(pool_size=(2, 2), strides=2),

    tf.keras.layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu', padding = 'same'),
    tf.keras.layers.MaxPool2D(pool_size=(2, 2), strides=2),

    tf.keras.layers.Conv2D(filters=128, kernel_size=(3, 3), activation='relu', padding = 'same'),
    tf.keras.layers.MaxPool2D(pool_size=(2, 2), strides=2),

    tf.keras.layers.Conv2D(filters=256, kernel_size=(3, 3), activation='relu', padding = 'same'),
    tf.keras.layers.MaxPool2D(pool_size=(2, 2), strides=2),

    tf.keras.layers.Flatten(),

    tf.keras.layers.Dense(1024,activation ="selu"),
    tf.keras.layers.Dense(512,activation ="selu"),
    tf.keras.layers.Dense(29,activation ="softmax")
])

"""compiling the model"""

model_cnn.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')

"""Training the model"""

model_cnn.fit(train_data_cnn, train_target, validation_split=0.3, epochs=10)

"""Finding loss and accuracy"""

loss, accuracy = model_cnn.evaluate(test_data_cnn, test_target)

print("Accuracy =", accuracy)
print("Loss =", loss)

"""Making predections"""

cnn_predections = model_cnn.predict(test_data_cnn)

"""Implementation"""

img = random.randint(0, len(cnn_predections) - 1)
print("Predection =", np.argmax(cnn_predections[img]))
plt.imshow(test_data.values[img].reshape(32,32).transpose(1,0))